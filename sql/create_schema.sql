DROP TABLE order_history CASCADE CONSTRAINTS;
DROP TABLE position_history CASCADE CONSTRAINTS;
DROP TABLE employees CASCADE CONSTRAINTS;
DROP TABLE positions CASCADE CONSTRAINTS;
DROP TABLE job_history CASCADE CONSTRAINTS;
DROP TABLE payments CASCADE CONSTRAINTS;
DROP TABLE jobs CASCADE CONSTRAINTS;
DROP TABLE orders CASCADE CONSTRAINTS;
DROP TABLE pallets CASCADE CONSTRAINTS;
DROP TABLE accounts CASCADE CONSTRAINTS;
DROP TABLE locations CASCADE CONSTRAINTS;
DROP TABLE shelf_type CASCADE CONSTRAINTS;

CREATE TABLE shelf_type
(
    shelf_type_id     INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,
    max_weight        INTEGER NOT NULL,
    max_size          INTEGER NOT NULL,
    shelf_description VARCHAR(255)
);

CREATE TABLE locations
(
    location_id   INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,
    type          VARCHAR(255) NOT NULL
        CONSTRAINT location_type_enum CHECK ( type IN ('SHELF', 'IN_RAMP', 'OUT_RAMP') ),
    path          VARCHAR(255) NOT NULL,
    shelf_type_id INTEGER
        CONSTRAINT loc_shelf_type REFERENCES shelf_type (shelf_type_id)
);

CREATE TABLE accounts
(
    account_username VARCHAR(255) PRIMARY KEY,
    password         VARCHAR(255) NOT NULL,
    type             VARCHAR(255) NOT NULL
        CONSTRAINT account_type_enum CHECK ( type IN ('MANAGER', 'CLIENT', 'WORKER') ),
    name             VARCHAR(255),
    surname          VARCHAR(255)
);

CREATE TABLE pallets
(
    pallet_id      INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,
    description    VARCHAR(255),
    owner_username VARCHAR(255) NOT NULL
        CONSTRAINT pal_own_fk REFERENCES accounts (account_username),
    location_id    INTEGER      NOT NULL
        CONSTRAINT location_fk REFERENCES locations (location_id)
);

CREATE TABLE orders
(
    order_id        INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,
    client_username VARCHAR(255) NOT NULL
        CONSTRAINT order_client_fk REFERENCES accounts (account_username),
    type            VARCHAR(255) NOT NULL
        CONSTRAINT client_type_enum CHECK ( type IN ('IN', 'OUT') )
);

CREATE TABLE jobs
(
    job_id                   INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,
    destination_id           INTEGER      NOT NULL
        CONSTRAINT job_destination_fk REFERENCES locations (location_id),
    pallet_id                INTEGER      NOT NULL
        CONSTRAINT job_pallet_fk REFERENCES pallets (pallet_id),
    order_id                 INTEGER      NOT NULL
        CONSTRAINT job_order_fk REFERENCES orders (order_id),
    status                   VARCHAR(255) NOT NULL
        CONSTRAINT job_status_enum CHECK ( status IN ('PLANNED', 'PENDING', 'IN_PROGRESS', 'COMPLETED') ),
    assigned_worker_username VARCHAR(255)
        CONSTRAINT job_assigned_worker_fk REFERENCES accounts (account_username)
);

CREATE TABLE job_history
(
    job_hist_id  INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,
    job_id       INTEGER      NOT NULL
        CONSTRAINT job_hist_job_fk REFERENCES jobs (job_id),
    new_status   VARCHAR(255) NOT NULL
        CONSTRAINT job_hist_status_enum CHECK ( new_status IN ('PLANNED', 'PENDING', 'IN_PROGRESS', 'COMPLETED') ),
    date_changed DATE         NOT NULL
);

CREATE TABLE payments
(
    payment_id INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,
    order_id   INTEGER       NOT NULL
        CONSTRAINT payment_order REFERENCES orders (order_id),
    deadline   DATE,
    amount     NUMBER(10, 2) NOT NULL
);

CREATE TABLE positions
(
    position_id   INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,
    position_name VARCHAR(255)  NOT NULL,
    min_salary    NUMBER(10, 2) NOT NULL,
    max_salary    NUMBER(10, 2) NOT NULL
);

CREATE TABLE employees
(
    employee_id      INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,
    account_username VARCHAR(255)  NOT NULL
        CONSTRAINT account_username_fk REFERENCES accounts (account_username),
    salary           NUMBER(10, 2) NOT NULL,
    date_employed    DATE          NOT NULL,
    position_id      INTEGER       NOT NULL
        CONSTRAINT position_id_fk REFERENCES positions (position_id),
    manager_id       INTEGER
        CONSTRAINT manager_id_fk REFERENCES employees (employee_id)
);

CREATE TABLE position_history
(
    ph_id       INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,
    employee_id INTEGER
        CONSTRAINT employee_id_fk REFERENCES employees (employee_id),
    position_id INTEGER NOT NULL
        CONSTRAINT ph_pos_fk REFERENCES positions (position_id),
    date_start  DATE    NOT NULL,
    date_end    DATE    NOT NULL
);

CREATE TABLE order_history
(
    order_history_id INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 100) PRIMARY KEY,
    order_id         INTEGER      NOT NULL
        CONSTRAINT order_hist_fk REFERENCES orders (order_id),
    date_completed   DATE,
    client_id        VARCHAR(255) NOT NULL
        CONSTRAINT client_hist_fk REFERENCES accounts (account_username)
);

CREATE OR REPLACE TRIGGER check_shelf_has_one_pallet
    BEFORE INSERT OR UPDATE OF location_id
    ON pallets
    FOR EACH ROW
DECLARE
    new_loc      LOCATIONS%ROWTYPE;
    pallet_count INTEGER;
BEGIN
    SELECT * INTO new_loc FROM locations WHERE location_id = :new.location_id;
    IF new_loc.type = 'SHELF' THEN
        SELECT COUNT(*) INTO pallet_count FROM pallets WHERE location_id = new_loc.location_id;
        IF pallet_count > 1 THEN
            RAISE_APPLICATION_ERROR(-20002, 'Shelf cannot have more than 1 pallet');
        END IF;
    END IF;
END;
/

CREATE OR REPLACE TRIGGER check_worker_assigned_to_job
    BEFORE INSERT OR UPDATE OF assigned_worker_username
    ON jobs
    FOR EACH ROW
DECLARE
    acc_type VARCHAR(255);
BEGIN
    IF :new.assigned_worker_username IS NOT NULL THEN
        SELECT accounts.type
        INTO acc_type
        FROM accounts
        WHERE :new.assigned_worker_username = accounts.account_username;

        IF acc_type <> 'WORKER' THEN
            RAISE_APPLICATION_ERROR(-20000, 'Can only assign workers to a job');
        END IF;
    END IF;
END;
/

CREATE
    OR
    REPLACE TRIGGER check_client_assigned_to_order
    BEFORE
        INSERT OR
        UPDATE OF client_username
    ON orders
    FOR EACH ROW
DECLARE
    acc_type VARCHAR(255);
BEGIN
    SELECT accounts.type INTO acc_type FROM accounts WHERE :new.client_username = accounts.account_username;
    IF acc_type <> 'CLIENT' THEN
        RAISE_APPLICATION_ERROR(-20001, 'Only clients can make orders');
    END IF;
END;
/

CREATE OR REPLACE FUNCTION order_price(p_order_id INTEGER)
    RETURN NUMBER AS
    v_order_price         NUMBER(10, 2);
    v_jobs_number         INTEGER;
    c_threshold1 CONSTANT NUMBER(2, 2) := 50;
    c_threshold2 CONSTANT NUMBER(2, 2) := 30;

BEGIN

    SELECT COUNT(*)
    INTO v_jobs_number
    FROM jobs
    WHERE order_id = p_order_id;

    IF v_jobs_number < 10 THEN
        v_order_price := c_threshold1 * v_jobs_number;
    ELSE
        v_order_price := c_threshold2 * v_jobs_number;
    END IF;

    RETURN v_order_price;
END;
/

CREATE OR REPLACE FUNCTION manager_bonus(p_man_id INTEGER)
    RETURN NUMBER AS
    v_workers_number INTEGER;
    v_bonus          NUMBER(10, 2);

BEGIN

    SELECT COUNT(*)
    INTO v_workers_number
    FROM employees
    WHERE manager_id = p_man_id;

    v_bonus := v_workers_number * 20;

    RETURN v_bonus;
END;
/

CREATE OR REPLACE TRIGGER order_history_add
    AFTER
        UPDATE OF status
    ON jobs
DECLARE
    unfinished_jobs INTEGER;
BEGIN
    FOR "ORDER" IN (SELECT * FROM orders)
        LOOP
            SELECT COUNT(*)
            INTO unfinished_jobs
            FROM jobs
            WHERE jobs.order_id = "ORDER".order_id
              AND jobs.status <> 'COMPLETED';

            IF unfinished_jobs = 0 THEN
                INSERT INTO order_history (order_id, date_completed, client_id)
                VALUES ("ORDER".order_id, SYSDATE, "ORDER".client_username);
            END IF;
        END LOOP;

END;
/

CREATE OR REPLACE PROCEDURE create_job_out(username VARCHAR, order_type VARCHAR,
                                           job_pallet_id INTEGER, job_status VARCHAR)
AS
    order_id       INTEGER;
    destination_id INTEGER;
BEGIN
    INSERT INTO orders (client_username, "TYPE") VALUES (username, order_type);

    SELECT o.order_id
    INTO order_id
    FROM orders o
    WHERE o.order_id = (SELECT MAX(o2.order_id) FROM orders o2);

    SELECT l.location_id
    INTO destination_id
    FROM locations l
    WHERE l.type = 'OUT_RAMP';

    INSERT INTO jobs (destination_id, pallet_id, order_id, status)
    VALUES (destination_id, job_pallet_id, order_id, job_status);
END;
/

CREATE OR REPLACE PROCEDURE assign_worker(w_id VARCHAR, j_id INTEGER)
AS
BEGIN
    UPDATE jobs SET status = 'IN_PROGRESS' WHERE job_id = j_id;
    UPDATE jobs SET assigned_worker_username = w_id WHERE job_id = j_id;
END;
/

CREATE OR REPLACE PROCEDURE unasssign_worker(j_id INTEGER)
AS
BEGIN
    UPDATE jobs SET status = 'PENDING' WHERE job_id = j_id;
    UPDATE jobs SET assigned_worker_username = NULL WHERE job_id = j_id;
END;
/

CREATE OR REPLACE PROCEDURE complete_job(p_job_id INTEGER)
AS
    v_job_dest_id   INTEGER;
    v_job_pallet_id INTEGER;
BEGIN
    UPDATE jobs
    SET status                   = 'COMPLETED',
        assigned_worker_username = NULL
    WHERE job_id = p_job_id;

    SELECT destination_id, pallet_id
    INTO v_job_dest_id, v_job_pallet_id
    FROM jobs
    WHERE job_id = p_job_id;

    UPDATE pallets
    SET location_id = v_job_dest_id
    WHERE pallet_id = v_job_pallet_id;

END;
/

CREATE OR REPLACE PROCEDURE create_job(username VARCHAR, order_type VARCHAR,
                                       pallet_description VARCHAR, job_status VARCHAR)
AS
    order_id       INTEGER;
    pallet_id      INTEGER;
    destination_id INTEGER;
BEGIN
    INSERT INTO orders (client_username, "TYPE") VALUES (username, order_type);
    SELECT o.order_id
    INTO order_id
    FROM orders o
    WHERE o.order_id = (SELECT MAX(o2.order_id) FROM orders o2);

    SELECT l.location_id
    INTO destination_id
    FROM locations l
    WHERE l.type = 'IN_RAMP';

    INSERT INTO pallets(description, owner_username, location_id)
    VALUES (pallet_description, username, destination_id);
    SELECT p.pallet_id
    INTO pallet_id
    FROM pallets p
    WHERE p.pallet_id = (SELECT MAX(p2.pallet_id) FROM pallets p2);

    INSERT INTO jobs (destination_id, pallet_id, order_id, status)
    VALUES (pallet_id, destination_id, order_id, job_status);
END;
/

CREATE OR REPLACE PROCEDURE show_clients_payments
AS
    v_client       ACCOUNTS%ROWTYPE;
    v_id_client    INTEGER;
    v_all_payments NUMBER(10, 2);
    CURSOR cr_clients IS SELECT *
                         FROM accounts;
BEGIN
    OPEN cr_clients;
    LOOP
        EXIT WHEN cr_clients%NOTFOUND;
        FETCH cr_clients INTO v_client;

        IF v_client.type != 'CLIENT' THEN
            CONTINUE;
        ELSE

            SELECT id_client.nextval
            INTO v_id_client
            FROM dual;

            SELECT SUM(p.amount)
            INTO v_all_payments
            FROM payments p
                     JOIN orders o USING (order_id)
            WHERE o.client_username = v_client.account_username;

            dbms_output.put_line(v_client.account_username || ' - total amount: '
                || v_all_payments);
        END IF;
    END LOOP;
    CLOSE cr_clients;
END;
/